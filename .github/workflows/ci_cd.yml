name: CI/CD

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

env:
  PYTHON_VERSION: "3.13"
  DOCKER_IMAGE: "${{ vars.DOCKERHUB_USERNAME }}/heart-predict-api"
  APP_CONTAINER_NAME: "heart-predict-api"

jobs:
  # ==========================================
  # CODE LINTING 
  # ==========================================
  lint:
    name: Code Linting
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
            pip install flake8 pylint black isort autopep8
    
      - name: Initialize lint summary file
        run: |
            echo "Linting & Formatting Results" > lint-summary.txt
            echo "" >> lint-summary.txt
            echo "## Linting & Formatting Results" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"

      - name: Use Flake8 (PEP 8 Style Enforcement)
        run: |
          {
            echo "### 1. Flake8 (PEP 8 Style Enforcement)"
            echo '```'
            flake8 src/ \
              --max-line-length=100 \
              --max-complexity=10 \
              --statistics \
              --count \
              --show-source \
              --exclude=__pycache__,*.pyc,.git,__init__.py,migrations || true
            echo '```'
            echo ""
          } | tee -a lint-summary.txt >> "${GITHUB_STEP_SUMMARY:-/dev/null}"

      - name: Validate Code Quality
        run: |
          {
            echo "### 2. Pylint (Code Quality)"
            echo '```'
            pylint src/ \
              --output-format=text \
              --reports=y \
              --disable=C0111,C0103,R0903,W0212 \
              --fail-under=7.0 \
              --max-line-length=100 || true
            echo '```'
            echo ""
          } | tee -a lint-summary.txt >> "${GITHUB_STEP_SUMMARY:-/dev/null}"

      - name: Check Code Formatting
        run: |
          {
            echo "### 3. Black (Code Formatting)"
            echo '```'
            black --check --diff --line-length=100 src/ || true
            echo '```'
            echo ""
            echo "Hint: run 'black --line-length=100 src/' locally to auto-format if needed."
            echo ""
          } | tee -a lint-summary.txt >> "${GITHUB_STEP_SUMMARY:-/dev/null}"

      - name: Check Import Order
        run: |
          {
            echo "### 4. isort (Import Organization)"
            echo '```'
            # Check-only, do not modify code
            isort --check-only --diff --profile black src/ || true
            echo '```'
            echo ""
            echo "Hint: run 'isort --profile black src/' locally to auto-sort imports if needed."
            echo ""
          } | tee -a lint-summary.txt >> "${GITHUB_STEP_SUMMARY:-/dev/null}"
      - name: Generate Lint Summary
        if: success()
        run: |
            echo "---" | tee -a lint-summary.txt >> "$GITHUB_STEP_SUMMARY"
            echo "All linting checks passed." | tee -a lint-summary.txt >> "$GITHUB_STEP_SUMMARY"

      - name: Upload lint summary artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: lint-summary
          path: lint-summary.txt
          compression-level: 6

  # ==========================================
  # SECURITY ANALYSIS
  # ========================================== 
  security:
    name: Security Analysis
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install bandit safety pip-audit


      - name: Initialize security summary file
        run: |
          echo "Security Analysis Results" > security-summary.txt
          echo "" >> security-summary.txt
          echo "## Security Analysis Results" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

      - name: Security Linter
        run: |
          {
            echo "### 1. Bandit (Python Security Linter)"
            echo '```'
            bandit -r src/ \
              -f txt \
              --severity-level medium \
              --confidence-level medium \
              --skip B101,B601 \
              -ll || true
            echo '```'
            echo ""
          } | tee -a security-summary.txt >> "${GITHUB_STEP_SUMMARY:-/dev/null}"

      - name: Check Dependency Vulnerabilities
        run: |
          pip freeze > requirements-frozen.txt

          {
            echo "### 2. Safety (Dependency Vulnerabilities)"
            echo '```'
            safety check \
              --file requirements-frozen.txt \
              --output text || true
            echo '```'
            echo ""
          } | tee -a security-summary.txt >> "${GITHUB_STEP_SUMMARY:-/dev/null}"

      - name: Check Package Security
        run: |
          {
            echo "### 3. pip-audit (PyPI Package Security)"
            echo '```'
            pip-audit \
              --requirement requirements-frozen.txt \
              --format json \
              --output pip-audit-report.json || true
            echo '```'
            echo ""
          } | tee -a security-summary.txt >> "${GITHUB_STEP_SUMMARY:-/dev/null}"

          mkdir -p security-reports
          mv pip-audit-report.json security-reports/pip-audit-report.json || true

      - name: Secret Detection
        run: |
          SECRET_PATTERNS=(
            "password\s*=\s*['\"].*['\"]"
            "api[_-]?key\s*=\s*['\"].*['\"]"
            "secret\s*=\s*['\"].*['\"]"
            "token\s*=\s*['\"].*['\"]"
            "aws[_-]?(access|secret)[_-]?key"
          )

          : > secrets-report.txt

          for pattern in "${SECRET_PATTERNS[@]}"; do
            grep -r -i -E "$pattern" src/ --exclude-dir=__pycache__ >> secrets-report.txt 2>&1 || true
          done

          {
            echo "### 5. Secret Detection"
            echo '```'
            if [ -s secrets-report.txt ]; then
              cat secrets-report.txt
              echo ""
              echo "Potential hardcoded secrets found."
              echo "Please review and use environment variables or secret managers instead."
            else
              echo "No hardcoded secrets detected."
            fi
            echo '```'
            echo ""
          } | tee -a security-summary.txt >> "${GITHUB_STEP_SUMMARY:-/dev/null}"
      
      - name: Generate Security Summary
        if: success()
        run: |
          echo "---" | tee -a security-summary.txt >> "$GITHUB_STEP_SUMMARY"
          echo "All security checks passed." | tee -a security-summary.txt >> "$GITHUB_STEP_SUMMARY"

      - name: Upload security summary artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-summary
          path: |
            security-summary.txt

  # ==========================================
  # TESTING & COVERAGE
  # ==========================================
  test:
    name: Tests & Coverage
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov pytest-html pytest-xdist pytest-timeout coverage

      - name: Initialize test summary file
        run: |
          echo "Test and Coverage Results" > test-summary.txt
          echo "" >> test-summary.txt
          echo "## Test and Coverage Results" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

      - name: Run Unit Tests with Coverage
        id: unit-tests
        run: |
          echo "### 1. Test Execution" | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"
          echo '```' | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"

          # Run tests with coverage
          pytest tests/ \
            -v \
            --cov=src \
            --cov-report=term-missing \
            --cov-report=xml:coverage.xml \
            --cov-report=html:htmlcov \
            --cov-report=json:coverage.json \
            --html=test-report.html \
            --self-contained-html \
            --junitxml=junit.xml \
            --maxfail=5 \
            --tb=short \
            -n auto 2>&1 | tee test-output.txt

          # Tail key lines into the summary
          tail -30 test-output.txt | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"

          echo '```' | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"
          echo "" | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"

      - name: Generate Coverage Report
        if: always()
        run: |
          echo "### 2. Code Coverage Report" | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"
          echo "" | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"

          if [ -f coverage.json ]; then
            COVERAGE=$(python3 -c "import json; data=json.load(open('coverage.json')); print(f\"{data['totals']['percent_covered']:.2f}\")" 2>/dev/null || echo "0")

            echo "**Total Coverage:** ${COVERAGE}%" | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"
            echo "" | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"

            # Detailed coverage report
            echo "#### 2.1 Detailed Coverage by Module" | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"
            echo '```' | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"
            coverage report --skip-covered >> coverage-report.txt 2>/dev/null || echo "Coverage report not available" >> coverage-report.txt

            cat coverage-report.txt | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"
            echo '```' | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"
            echo "" | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"

            # Missing coverage
            echo "#### 2.2 Files with Missing Coverage" | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"
            echo '```' | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"
            coverage report --skip-covered --show-missing > coverage-missing.txt 2>/dev/null || echo "Coverage report not available" > coverage-missing.txt

            # Filter out fully covered files, if any
            if grep -v "100%" coverage-missing.txt > coverage-missing-filtered.txt 2>/dev/null && [ -s coverage-missing-filtered.txt ]; then
              cat coverage-missing-filtered.txt | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"
            else
              echo "All files have 100% coverage." | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"
            fi

            echo '```' | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"
            echo "" | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"
          else
            echo "Coverage data not available" | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Check Coverage Threshold
        run: |
          echo "### 3. Coverage Threshold Check" | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"
          echo "" | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"

          if [ -f coverage.json ]; then
            COVERAGE=$(python3 -c "import json; print(json.load(open('coverage.json'))['totals']['percent_covered'])" 2>/dev/null || echo 0)
            THRESHOLD=60

            if (( $(echo "$COVERAGE < $THRESHOLD" | bc -l) )); then
              MSG="Coverage (${COVERAGE}%) is below threshold (${THRESHOLD}%)"
              echo "$MSG" | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"
              echo "$MSG"
              exit 1
            else
              MSG="Coverage (${COVERAGE}%) meets threshold (${THRESHOLD}%)"
              echo "$MSG" | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"
              echo "$MSG"
            fi
          else
            echo "Coverage threshold check skipped: coverage.json not found" | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"
          fi

          echo "" | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"

      - name: Final Test Summary
        if: success()
        run: |
          echo "---" | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"
          echo "All tests passed and coverage meets the required threshold." | tee -a test-summary.txt >> "$GITHUB_STEP_SUMMARY"

      # Single artifact with tests + coverage outputs
      - name: Upload test and coverage artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-summary
          path: |
            test-summary.txt
            test-output.txt
            coverage.xml
            junit.xml
            htmlcov/
            test-report.html
          compression-level: 6

  # ==========================================
  # DOWNLOAD DATA & PROCESS
  # ==========================================
  data:
    name: Download Dataset & Process
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Clean previous data
        run: |
          echo "Cleaning previous data directories..."
          rm -rf data/raw data/processed artifacts models || true
          mkdir -p data/raw data/processed artifacts models

      - name: Download dataset
        run: |
          echo "Running: python -m src.data.download_data"
          python -m src.data.download_data

      - name: Convert UCI data to CSV
        run: |
          echo "Running: python -m src.data.convert_uci_to_csv"
          python -m src.data.convert_uci_to_csv

      - name: Preprocess CSV files
        run: |
          echo "Running: python -m src.data.preprocess"
          python -m src.data.preprocess

      - name: Verify processed dataset
        run: |
          if [ ! -f "data/processed/heart_clean.csv" ]; then
            echo "ERROR: data/processed/heart_clean.csv not found after preprocessing."
            exit 1
          fi

      - name: Upload processed dataset artifact
        uses: actions/upload-artifact@v4
        with:
          name: processed-data
          path: data/processed/heart_clean.csv
          if-no-files-found: error


  # ==========================================
  # TRAIN MODEL
  # ==========================================
  train-model:
    name: Train Model
    runs-on: ubuntu-latest
    needs: data

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Download processed dataset artifact
        uses: actions/download-artifact@v4
        with:
          name: processed-data
          path: data/processed

      - name: Train model
        env:
          PROCESSED_DATA_PATH: data/processed/heart_clean.csv
        run: |
          echo "Using processed data at: $PROCESSED_DATA_PATH"
          echo "Running: python -m src.models.train_model"
          python -m src.models.train_model

      - name: Upload trained model artifact
        uses: actions/upload-artifact@v4
        with:
          name: heart-model
          path: models/
          if-no-files-found: error
      - name: Upload MLflow tracking DB
        uses: actions/upload-artifact@v4
        with:
          name: mlflow-db
          path: mlflow/mlflow.db         
          if-no-files-found: error
          
  # ==========================================
  # MLFLOW REPORT
  # ==========================================
  mlflow-report:
    name: MLflow Report
    runs-on: ubuntu-latest
    needs: train-model

    steps:
      - name: Download MLflow tracking DB
        uses: actions/download-artifact@v4
        with:
          name: mlflow-db
          path: mlflow-db

      - name: Show MLflow runs in job summary
        run: |
          echo "## MLflow Experiment Summary" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          DB_PATH="mlflow-db/mlflow.db"

          if [ ! -f "$DB_PATH" ]; then
            echo "MLflow DB not found at $DB_PATH" >> "$GITHUB_STEP_SUMMARY"
            exit 1
          fi

          echo "Using database: \`$DB_PATH\`" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          echo "### Latest Runs" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "| Run ID | Experiment ID | Status | Start Time | End Time |" >> "$GITHUB_STEP_SUMMARY"
          echo "|-------|---------------|--------|-----------|----------|" >> "$GITHUB_STEP_SUMMARY"

          # Query runs table from MLflow DB (SQLite)
          # Adjust column names if your MLflow version differs.
          sqlite3 -header -csv "$DB_PATH" "
            SELECT run_uuid, experiment_id, status, start_time, end_time
            FROM runs
            ORDER BY start_time DESC
            LIMIT 10;
          " | tail -n +2 | while IFS=',' read -r run_id exp_id status start_time end_time; do
            echo "| $run_id | $exp_id | $status | $start_time | $end_time |" >> "$GITHUB_STEP_SUMMARY"
          done

          echo "" >> "$GITHUB_STEP_SUMMARY"

  # ==========================================
  # DOCKER BUILD & VALIDATE
  # ==========================================
  docker-build:
    name: Docker Build & Validate
    runs-on: ubuntu-latest
    needs:
      - lint
      - security
      - test
      - train-model

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download trained model artifact
        uses: actions/download-artifact@v4
        with:
          name: heart-model
          path: models/

      - name: Set Docker image name
        id: image-name
        run: |
          echo "IMAGE=${DOCKER_IMAGE}" >> "$GITHUB_OUTPUT"

      - name: Build Docker image (candidate)
        run: |
          docker build \
            -f docker/Dockerfile \
            -t ${{ steps.image-name.outputs.IMAGE }}:candidate \
            .

      - name: Run container for validation
        run: |
          docker stop ${{ env.APP_CONTAINER_NAME }} || true
          docker rm ${{ env.APP_CONTAINER_NAME }} || true

          docker run -d \
            --name ${{ env.APP_CONTAINER_NAME }} \
            -p 8000:8000 \
            ${{ steps.image-name.outputs.IMAGE }}:candidate

          echo "Container started, waiting for app to be ready..."
          sleep 20

      - name: Validate Docker image endpoint
        run: |
          echo "Calling http://127.0.0.1:8000/health"
          curl --fail --max-time 30 http://127.0.0.1:8000/health | tee health_response.json

          if command -v jq >/dev/null 2>&1; then
            status=$(jq -r '.status' health_response.json)
            if [ "$status" != "ok" ]; then
              echo "Expected status=ok but got: $status"
              exit 1
            fi
          else
            if ! grep -q '"status"' health_response.json || ! grep -q '"ok"' health_response.json; then
              echo "Response does not contain expected status=ok"
              cat health_response.json
              exit 1
            fi
          fi

          echo "Local container health check passed."

      - name: Stop and remove validation container
        if: always()
        run: |
          docker stop ${{ env.APP_CONTAINER_NAME }} || true
          docker rm ${{ env.APP_CONTAINER_NAME }} || true  

  # ==========================================
  # PUSH TO DOCKER HUB
  # ==========================================
  docker-push:
    name: Push to Docker Hub
    runs-on: ubuntu-latest
    needs: docker-build

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download trained model artifact
        uses: actions/download-artifact@v4
        with:
          name: heart-model
          path: models/

      - name: Set Docker image name
        id: image-name
        run: |
          echo "IMAGE=${DOCKER_IMAGE}" >> "$GITHUB_OUTPUT"

      - name: Compute short SHA
        id: short-sha
        run: |
          SHORT_SHA="${GITHUB_SHA::8}"
          echo "SHORT_SHA=${SHORT_SHA}" >> "$GITHUB_OUTPUT"

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./docker/Dockerfile
          push: true
          tags: |
            ${{ steps.image-name.outputs.IMAGE }}:latest
            ${{ steps.image-name.outputs.IMAGE }}:${{ steps.short-sha.outputs.SHORT_SHA }}

      - name: Show pushed image tags
        run: |
          echo "Pushed Docker image:"
          echo "  ${{ steps.image-name.outputs.IMAGE }}:latest"
          echo "  ${{ steps.image-name.outputs.IMAGE }}:${{ steps.short-sha.outputs.SHORT_SHA }}"
  
  # ==========================================
  # DEPLOY TO CLOUD
  # ==========================================
  cloud-deploy:
    name: Deploy to Cloud
    runs-on: ubuntu-latest
    needs: docker-push
    if: github.ref == 'refs/heads/master'

    steps:
      - name: Set Docker image name
        id: image-name
        run: |
          echo "IMAGE=${DOCKER_IMAGE}" >> "$GITHUB_OUTPUT"

      - name: Install SSH client
        run: |
          sudo apt-get update
          sudo apt-get install -y openssh-client curl

      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.CLOUD_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          printf "Host cloud-server\n  HostName %s\n  User %s\n  IdentityFile ~/.ssh/id_rsa\n  StrictHostKeyChecking no\n" \
            "${{ secrets.CLOUD_HOST }}" "${{ secrets.CLOUD_SSH_USER }}" >> ~/.ssh/config

      - name: Ensure Docker is installed on cloud server
        run: |
          ssh cloud-server << 'EOF'
          set -e

          echo "=== Checking if Docker is installed ==="
          if ! command -v docker >/dev/null 2>&1; then
            echo "Docker not found. Installing Docker..."
            curl -fsSL https://get.docker.com | sh
          else
            echo "Docker is already installed."
          fi
          EOF

      - name: Stop and remove existing app container on cloud server
        run: |
          ssh cloud-server << 'EOF'
          set -e

          echo "=== Cleaning up old containers for this app ==="
          if docker ps -a --format '{{.Names}}' | grep -wq "${{ env.APP_CONTAINER_NAME }}"; then
            echo "Stopping and removing existing container ${{ env.APP_CONTAINER_NAME }}..."
            docker stop ${{ env.APP_CONTAINER_NAME }} || true
            docker rm ${{ env.APP_CONTAINER_NAME }} || true
          else
            echo "No existing container named ${{ env.APP_CONTAINER_NAME }}."
          fi
          EOF

      - name: Remove old app images on cloud server
        run: |
          ssh cloud-server << 'EOF'
          set -e

          echo "=== Cleaning old images for this app (if any) ==="
          PROJECT_IMAGE="${{ steps.image-name.outputs.IMAGE }}"
          old_images=$(docker images --format '{{.Repository}}:{{.Tag}}' | grep "^$PROJECT_IMAGE" || true)
          if [ -n "$old_images" ]; then
            echo "Found old images:"
            echo "$old_images"
            echo "Removing old images..."
            echo "$old_images" | xargs -r docker rmi || true
          else
            echo "No old images for $PROJECT_IMAGE."
          fi
          EOF

      - name: Pull latest image on cloud server
        run: |
          ssh cloud-server << 'EOF'
          set -e

          echo "=== Pulling latest image from registry ==="
          docker pull ${{ steps.image-name.outputs.IMAGE }}:latest
          EOF

      - name: Run new app container on cloud server
        run: |
          ssh cloud-server << 'EOF'
          set -e

          echo "=== Running new container ==="
          docker run -d \
            --name ${{ env.APP_CONTAINER_NAME }} \
            -p 80:8000 \
            --restart always \
            ${{ steps.image-name.outputs.IMAGE }}:latest

          echo "Deployment on cloud server completed."
          EOF

  # ==========================================
  # HEALTH CHECK
  # ==========================================
  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: cloud-deploy
    if: github.ref == 'refs/heads/master'

    steps:
      - name: Install curl
        run: |
          sudo apt-get update
          sudo apt-get install -y curl

      - name: Check API /health on server
        run: |
          HEALTH_URL="http://${{ secrets.CLOUD_HOST }}/health"
          echo "Checking health at: $HEALTH_URL"

          for i in {1..10}; do
            if curl --silent --fail "$HEALTH_URL" -o server_health_response.json; then
              echo "Health endpoint is responding."
              cat server_health_response.json
              break
            else
              echo "Health check failed, retrying in 5s... (attempt $i/10)"
              sleep 5
            fi
          done

          if [ ! -f server_health_response.json ]; then
            echo "Health endpoint did not respond after retries."
            exit 1
          fi

          if ! grep -q '"status"' server_health_response.json || ! grep -q '"ok"' server_health_response.json; then
            echo "Server health response does not contain expected status=ok"
            cat server_health_response.json
            exit 1
          fi

          echo "Cloud server health check passed."